<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Lightpole Tracker (GPS + Filter + Details)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; font-family: "Segoe UI", Tahoma, sans-serif; background: #f5f6fa; }
    /* ‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏ï‡πá‡∏°‡∏à‡∏≠‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠ */
    #map { height: 100dvh; }
    @supports not (height: 100dvh){ #map { height: 100vh; } }

    /* ‡∏Ç‡∏¢‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°‡∏ã‡∏π‡∏°‡∏•‡∏á ~50px */
    .leaflet-top.leaflet-left { top: 50px !important; }

    .status-bar {
      position: fixed; bottom: 10px; left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px 14px; border-radius: 10px;
      font-size: 14px; box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      z-index: 1000; line-height: 1.4; max-width: 90%;
    }

    .user-input {
      position: fixed; bottom: 65px; left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px 12px; border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      z-index: 2000; display: flex; align-items: center; gap: 8px;
    }
    .user-input input {
      border: 1px solid #ccc; border-radius: 6px;
      padding: 5px 8px; font-size: 14px; width: 150px;
    }

    .refresh-btn, .track-btn {
      position: fixed; top: 15px;
      background: #007bff; color: #fff; border: none;
      padding: 10px 14px; border-radius: 8px;
      font-size: 14px; font-weight: bold; cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      transition: background 0.2s ease; z-index: 2000;
      min-height: 40px; min-width: 40px; touch-action: manipulation;
    }
    .refresh-btn { right: 15px; }
    .track-btn { left: 15px; background: #28a745; }
    .track-btn.stop { background: #dc3545; }

    .legend {
      position: fixed; bottom: 20px; right: 20px;
      background: rgba(255,255,255,0.95);
      padding: 10px 12px; border-radius: 8px;
      font-size: 13px; box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      line-height: 1.6; z-index: 9999;
    }
    .legend div { display: flex; align-items: center; gap: 6px; }
    .legend-color { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #666; }

    .toast {
      position: fixed; top: 20px; right: 20px;
      background: #333; color: #fff;
      padding: 12px 20px; border-radius: 6px;
      font-size: 14px; opacity: 0;
      transition: opacity 0.5s, transform 0.3s;
      z-index: 3000; transform: translateY(-20px);
    }
    .toast.show { opacity: 1; transform: translateY(0); }

    .btn-row { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px; }
    .btn { border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; font-size: 13px; }
    .btn-green { background: #28a745; color: #fff; }
    .btn-red   { background: #dc3545; color: #fff; }

    .leaflet-div-icon { background: transparent !important; border: none !important; box-shadow: none !important; }

    /* controls ‡∏ã‡πâ‡∏≤‡∏¢‡∏ö‡∏ô */
    .top-controls{
      position: fixed; top: 15px; left: 15px;
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
      z-index: 2000;
    }
    .top-controls .track-btn{ position: static !important; left: auto !important; top: auto !important; }

    .filter-bar{
      position: static !important;
      display: flex; align-items: center; gap: 8px;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px; border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      flex-wrap: nowrap; white-space: nowrap; overflow-x: auto; max-width: 92vw;
    }
    .filter-bar input {
      border: 1px solid #ccc; border-radius: 6px;
      padding: 6px 8px; font-size: 13px; width: 150px; flex: 0 0 auto;
    }
    .chip{
      border: 1px solid #ccc; background: #fff;
      padding: 6px 10px; border-radius: 999px; font-size: 13px; cursor: pointer;
      user-select: none; flex: 0 0 auto; min-height: 40px; min-width: 40px;
    }
    .chip.active{ background:#111; color:#fff; border-color:#111; }

    /* popup ‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢‡∏Ç‡∏∂‡πâ‡∏ô‡∏ô‡∏¥‡∏î */
    .leaflet-popup-content{ font-size:14px; }
    .leaflet-popup-content b{ font-size:15px; }

    /* Bottom sheet / side panel */
    :root{ --safe-top: env(safe-area-inset-top, 0px); --safe-bottom: env(safe-area-inset-bottom, 0px); }
    .sheet{
      position: fixed; left: 0; right: 0; bottom: 0;
      background: #fff; border-radius: 16px 16px 0 0;
      box-shadow: 0 -8px 24px rgba(0,0,0,.2);
      transform: translateY(100%); transition: transform .25s ease;
      z-index: 4000; max-height: calc(75dvh + var(--safe-bottom)); padding-bottom: var(--safe-bottom);
    }
    .sheet.open{ transform: translateY(0); }
    .sheet.hidden{ display: none; }
    .sheet-handle{
      width: 44px; height: 4px; border-radius: 999px;
      background: #ccc; margin: 10px auto;
    }
    .sheet-content{ padding: 8px 16px 16px; overflow: auto; max-height: 70dvh; }
    .sheet-title{ margin: 0 0 6px 0; font-size: 16px; }
    .meta-grid{
      display: grid; grid-template-columns: 1fr 1fr; gap: 8px 12px;
      font-size: 13.5px;
    }
    .meta-grid label{ display:block; font-size:12px; opacity:.7; margin-bottom:2px; }
    .links a{ display:inline-block; margin-right:8px; font-size:13.5px; }
    .sheet-actions{ display:flex; flex-wrap:wrap; gap:6px; margin-top:12px; }

    /* ‡∏à‡∏≠‡πÉ‡∏´‡∏ç‡πà: ‡πÅ‡∏™‡∏î‡∏á‡πÄ‡∏õ‡πá‡∏ô side panel ‡∏Ç‡∏ß‡∏≤ */
    @media (min-width: 900px){
      .sheet{
        left: auto; right: 16px; bottom: 16px;
        border-radius: 12px; width: 380px; transform: translateY(0);
      }
      .sheet.hidden{ display:none; }
    }
    /* ‡∏õ‡∏∏‡πà‡∏°‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏î‡∏ä‡∏ö‡∏≠‡∏£‡πå‡∏î */
.dash-btn{
  background:#6f42c1; /* ‡∏°‡πà‡∏ß‡∏á‡∏≠‡πà‡∏≤‡∏ô‡∏á‡πà‡∏≤‡∏¢ */
  color:#fff; text-decoration:none; border:none;
  padding:10px 12px; border-radius:8px;
  font-size:14px; font-weight:bold; cursor:pointer;
  box-shadow:0 2px 5px rgba(0,0,0,0.3);
  transition:background .2s ease; display:inline-flex; align-items:center; gap:6px;
}
.dash-btn:hover{ background:#5b36a4; }

/* ‡πÉ‡∏´‡πâ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏≠‡∏¢‡∏π‡πà‡∏†‡∏≤‡∏¢‡πÉ‡∏ï‡πâ .top-controls (‡πÑ‡∏°‡πà fixed) */
.top-controls .dash-btn{
  position:static !important; left:auto !important; top:auto !important;
}

  </style>
</head>
<body>
  <div class="user-input">
    <label for="username">üë§ ‡∏ú‡∏π‡πâ‡∏ï‡∏£‡∏ß‡∏à:</label>
    <input type="text" id="username" placeholder="‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏ï‡∏£‡∏ß‡∏à" />
  </div>

  <!-- controls ‡∏ã‡πâ‡∏≤‡∏¢‡∏ö‡∏ô -->
  <div class="top-controls">
    <button id="trackBtn" class="track-btn">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°</button>

  <!-- ‡∏õ‡∏∏‡πà‡∏°‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤‡πÅ‡∏î‡∏ä‡∏ö‡∏≠‡∏£‡πå‡∏î -->
  <a class="dash-btn"
     href="https://ksupanut16-exat.github.io/lightpole-tracker/dashboard.html"
     target="_blank" rel="noopener">
    üìä ‡πÅ‡∏î‡∏ä‡∏ö‡∏≠‡∏£‡πå‡∏î
  </a>

  <div class="filter-bar">
    <!-- ‡πÄ‡∏î‡∏¥‡∏° -->
  </div>
</div>

      <input type="text" id="searchInput" placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏≤‚Ä¶" />
      <button class="chip active" data-type="ALL">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
      <button class="chip" data-type="POLE">‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏™‡∏≤‡πÑ‡∏ü</button>
      <button class="chip" data-type="SP">‡πÄ‡∏â‡∏û‡∏≤‡∏∞ SP</button>
      <button class="chip" data-type="HM">‡πÄ‡∏â‡∏û‡∏≤‡∏∞ HM</button>
      <button class="chip" data-type="ON">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î</button>
      <button class="chip" data-type="OFF">‡πÑ‡∏ü‡∏î‡∏±‡∏ö</button>
      
    </div>
  </div>

  <button id="refreshBtn" class="refresh-btn">üîÑ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</button>
  <div id="map"></div>
  <div id="status" class="status-bar">üïì ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà...</div>

  <div class="legend">
    <b>üó∫Ô∏è ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏™‡∏µ:</b>
    <div><span class="legend-color" style="background: #ff66b2;"></span> SP</div>
    <div><span class="legend-color" style="background: #ffd54f;"></span> HM</div>
    <div><span class="legend-color" style="background: green;"></span> ‡πÑ‡∏ü‡∏ï‡∏¥‡∏î (A/B/AB)</div>
    <div><span class="legend-color" style="background: red;"></span> ‡πÑ‡∏ü‡∏î‡∏±‡∏ö (A/B/AB)</div>
  </div>

  <div id="toast" class="toast"></div>

  <!-- ‡πÄ‡∏™‡∏µ‡∏¢‡∏á -->
  <audio id="ding" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>

  <!-- Bottom Sheet / Side Panel -->
  <div id="detailsSheet" class="sheet hidden" aria-hidden="true">
    <div class="sheet-handle" role="button" id="sheetClose" title="‡∏õ‡∏¥‡∏î"></div>
    <div class="sheet-content">
      <h3 id="dName" class="sheet-title">-</h3>

      <div class="meta-grid">
        <div><label>‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£</label><div id="dItem">-</div></div>
        <div><label>‡∏ú‡∏π‡πâ‡∏ã‡πà‡∏≠‡∏°</label><div id="dMechanic">-</div></div>
        <div><label>‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î</label><div id="dLastFix">-</div></div>
        <div><label>‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á</label><div id="dDirection">-</div></div>
        <div><label>‡∏ú‡∏π‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î</label><div id="dLastEditor">-</div></div>
        <div><label>‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î</label><div id="dLastUpdated">-</div></div>
        <div id="dLinks" class="links"></div>
      </div>

      <div class="sheet-actions">
        <button id="dOnA"  class="btn btn-green">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î A</button>
        <button id="dOnB"  class="btn btn-green">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î B</button>
        <button id="dOnAB" class="btn btn-green">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î AB</button>
        <button id="dOffA" class="btn btn-red">‡πÑ‡∏ü‡∏î‡∏±‡∏ö A</button>
        <button id="dOffB" class="btn btn-red">‡πÑ‡∏ü‡∏î‡∏±‡∏ö B</button>
        <button id="dOffAB"class="btn btn-red">‡πÑ‡∏ü‡∏î‡∏±‡∏ö AB</button>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    /* ===== CONFIG ===== */
    const SHEET_ID = "1lOm7yLsXgSEod9A2l0YCerJdiHI2lD0m5JMPqYqmupY"; // ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    const SHEET_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json`;
    // üëâ ‡πÉ‡∏™‡πà URL Apps Script Web App ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì (‡∏•‡∏á‡∏ó‡πâ‡∏≤‡∏¢ /exec)
    const WEBHOOK_URL = "https://script.google.com/macros/s/AKfycbzgw0Qs5-MvsolZD4ncD4tzixdVQ4kYHraDIZQOgs_V5cqMYgQ647-2RmFoxBj4NV160g/exec";
    const PROXY = "https://corsproxy.io/?";

    /* ===== TUNING ===== */
    const MIN_STEP_M = 2;
    const NEAR_CHECK_MS = 3000;
    const ACCURACY_TRIGGER_MAX_M = 30;
    const ZOOM_IN_DIST_M = 5;
    const ZOOM_OUT_DIST_M = 10;
    const PER_PIN_COOLDOWN_MS = 90_000;
    const GLOBAL_COOLDOWN_MS  = 6_000;
    const AUTO_FIT_ON_REFRESH_WHEN_NOT_TRACKING = true;

    window.onload = () => {
      const map = L.map('map', { preferCanvas: true, maxZoom: 22 })
                   .setView([13.736717, 100.523186], 13);

      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 22,
        maxNativeZoom: 19,
        attribution: '&copy; OpenStreetMap contributors'
      }).addTo(map);

      const toast = document.getElementById("toast");
      const ding = document.getElementById("ding");
      const usernameInput = document.getElementById("username");
      const statusEl = document.getElementById("status");
      const trackBtn = document.getElementById("trackBtn");
      const refreshBtn = document.getElementById("refreshBtn");

      // Bottom sheet refs
      const sheetEl = document.getElementById("detailsSheet");
      const sheetClose = document.getElementById("sheetClose");
      const dName = document.getElementById("dName");
      const dItem = document.getElementById("dItem");
      const dMechanic = document.getElementById("dMechanic");
      const dLastFix = document.getElementById("dLastFix");
      const dDirection = document.getElementById("dDirection");
      const dLastEditor = document.getElementById("dLastEditor");
      const dLastUpdated = document.getElementById("dLastUpdated");
      const dLinks = document.getElementById("dLinks");

      /* === FILTER refs/state === */
      const searchInput = document.getElementById("searchInput");
      const chipButtons = Array.from(document.querySelectorAll(".chip"));
      let activeTypeFilter = "ALL"; // ALL | SP | HM | ON | OFF | POLE
      let searchQuery = "";

      let markers = [];
      let markerByName = new Map();
      let userMarker = null, userCircle = null;
      let userPath = [];
      let userPolyline = null;
      let watchID = null;
      let isZoomedIn = false;
      let firstDataLoaded = false;

      // throttling & cooldown
      let lastNearCheckAt = 0;
      let lastGlobalNotifyAt = 0;
      const perPinNotifiedAt = new Map(); // name -> timestamp

      /* ===== Helpers ===== */
      function showToast(msg, type="info") {
        toast.textContent = msg;
        toast.style.background = type === "success" ? "#28a745" : type === "error" ? "#dc3545" : "#333";
        toast.classList.add("show");
        setTimeout(() => toast.classList.remove("show"), 3000);
      }
      function toNumber(x) {
        if (typeof x === "number") return x;
        if (typeof x === "string") {
          const cleaned = x.trim().replace(/,/g, ".").replace(/[^\d.\-]/g, "");
          const n = Number(cleaned);
          return Number.isFinite(n) ? n : NaN;
        }
        return NaN;
      }
      function toText(x) { return (x ?? "").toString().trim(); }

      function getCodePrefix(x){
        const s = (x ?? "").toString().trim().toUpperCase();
        if (!s) return null;
        let m = s.match(/^(SP|HM)\b/);
        if (m) return m[1];
        m = s.match(/\b(SP|HM)\s*[- ]?\s*\d+/);
        return m ? m[1] : null;
      }
      function isSP(x){ return getCodePrefix(x) === "SP"; }
      function isHM(x){ return getCodePrefix(x) === "HM"; }

      function colorFor(status, name) {
        const s = toText(status), nm = toText(name);
        if (/‡πÑ‡∏ü‡∏î‡∏±‡∏ö/i.test(s)) return "red";
        if (/‡πÑ‡∏ü‡∏ï‡∏¥‡∏î/i.test(s)) return "green";
        if (/^SP/i.test(nm) || /^SP/i.test(s)) return "#ff66b2";
        if (/^HM/i.test(nm) || /^HM/i.test(s)) return "#ffd54f";
        return "blue";
      }

      function circleIcon(color) {
        return L.divIcon({
          html: `<div style="background:${color};width:18px;height:18px;border-radius:50%;border:2px solid white;"></div>`,
          className: ""
        });
      }

      // columns helpers
      function colIndexByLabels(cols, candidates){
        return cols.findIndex(c => {
          const label = (c?.label ?? "").toString().trim().toLowerCase();
          return candidates.some(x => label === x.toLowerCase());
        });
      }
      function cell(r, idx){ return r?.c?.[idx]?.v ?? r?.c?.[idx]?.f ?? ""; }

      // popup + ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏£‡∏¥‡∏° + ‡∏õ‡∏∏‡πà‡∏° "‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î"
      function createPopup(marker, name, status, color) {
        const m = marker.options.meta || {};
        function escapeHtml(s){
          return String(s ?? "").replace(/[&<>"]/g, c => (
            { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;' }[c]
          ));
        }
        function line(label, value) {
          const v = (value ?? "").toString().trim();
          return v ? `<div><small style="opacity:.7">${label}:</small> ${escapeHtml(v)}</div>` : "";
        }
        function link(label, url, emoji) {
          const u = (url ?? "").toString().trim();
          return u ? `<div>${emoji || "üîó"} <a href="${u}" target="_blank" rel="noopener noreferrer">${escapeHtml(label)}</a></div>` : "";
        }
        const extraHtml = `
          <div id="extraBox" style="margin-top:8px;font-size:12.5px;line-height:1.5">
            ${line("‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£", m.item)}
            ${line("‡∏ú‡∏π‡πâ‡∏ã‡πà‡∏≠‡∏°", m.mechanic)}
            ${line("‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î", m.lastFix)}
            ${line("‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á", m.direction)}
            ${line("‡∏ú‡∏π‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î", m.lastEditor)}
            ${line("‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î", m.lastUpdated)}
            ${link("‡∏£‡∏π‡∏õ‡∏ñ‡πà‡∏≤‡∏¢‡∏´‡∏ô‡πâ‡∏≤‡∏á‡∏≤‡∏ô", m.photo, "üì∑")}
            ${link("‡πÉ‡∏ö‡πÅ‡∏à‡πâ‡∏á‡∏á‡∏≤‡∏ô", m.ticket, "üìÑ")}
          </div>
        `;
        const div = document.createElement("div");
        div.innerHTML = `
          <b>${escapeHtml(name)}</b><br>
          üî∞ <b id="statusText" style="color:${color}">${escapeHtml(status || "-")}</b><br><br>

          <div class="btn-row">
            <button class="btn btn-green" id="onA">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î A</button>
            <button class="btn btn-green" id="onB">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î B</button>
            <button class="btn btn-green" id="onAB">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î AB</button>
            <button class="btn btn-red"   id="offA">‡πÑ‡∏ü‡∏î‡∏±‡∏ö A</button>
            <button class="btn btn-red"   id="offB">‡πÑ‡∏ü‡∏î‡∏±‡∏ö B</button>
            <button class="btn btn-red"   id="offAB">‡πÑ‡∏ü‡∏î‡∏±‡∏ö AB</button>
            <button class="btn" id="moreDetail">‚ÑπÔ∏è ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î</button>
          </div>

          ${extraHtml}
        `;
        const popup = L.popup().setContent(div);
        marker.bindPopup(popup);

        marker.on("popupopen", () => {
          const statusTextEl = div.querySelector("#statusText");
          function updateStatus(newStatus) {
            const newColor = colorFor(newStatus, name);
            statusTextEl.style.color = newColor;
            statusTextEl.textContent = newStatus;
            marker.setIcon(circleIcon(newColor));
            marker.options.status = newStatus;

            // ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï meta ‡πÄ‡∏û‡∏∑‡πà‡∏≠ UX (‡∏ä‡∏µ‡∏ï‡∏à‡∏∞‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏à‡∏£‡∏¥‡∏á‡∏ó‡∏≤‡∏á Apps Script)
            const editor = (usernameInput?.value || "").trim() || "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡∏ï‡∏£‡∏ß‡∏à";
            marker.options.meta = marker.options.meta || {};
            marker.options.meta.lastEditor = editor;
            marker.options.meta.lastUpdated = new Date().toLocaleString();

            ding.currentTime = 0; ding.play();
            sendStatusToSheet(name, newStatus);
            marker.closePopup();
            applyFilters();
          }
          div.querySelector("#onA").onclick  = () => updateStatus("‡πÑ‡∏ü‡∏ï‡∏¥‡∏îA");
          div.querySelector("#onB").onclick  = () => updateStatus("‡πÑ‡∏ü‡∏ï‡∏¥‡∏îB");
          div.querySelector("#onAB").onclick = () => updateStatus("‡πÑ‡∏ü‡∏ï‡∏¥‡∏îAB");
          div.querySelector("#offA").onclick = () => updateStatus("‡πÑ‡∏ü‡∏î‡∏±‡∏öA");
          div.querySelector("#offB").onclick = () => updateStatus("‡πÑ‡∏ü‡∏î‡∏±‡∏öB");
          div.querySelector("#offAB").onclick= () => updateStatus("‡πÑ‡∏ü‡∏î‡∏±‡∏öAB");

          div.querySelector("#moreDetail").onclick = () => openSheetFor(marker);
        });
      }

      // ‡∏™‡πà‡∏á‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÅ‡∏ö‡∏ö‡∏Å‡∏±‡∏ô‡∏û‡∏•‡∏≤‡∏î (proxy ‡∏•‡πà‡∏°‡∏Å‡πá‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡πÑ‡∏î‡πâ)
      async function sendStatusToSheet(name, newStatus) {
        const user = usernameInput.value.trim() || "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡∏ï‡∏£‡∏ß‡∏à";
        const payload = { name, status: newStatus, user };
        const proxyUrl = PROXY + encodeURIComponent(WEBHOOK_URL) + "&_ts=" + Date.now();

        async function tryProxy() {
          const r = await fetch(proxyUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json", "Cache-Control": "no-store" },
            body: JSON.stringify(payload),
            cache: "no-store",
          });
          if (!r.ok) throw new Error("proxy " + r.status);
          const j = await r.json();
          if (!j.ok) throw new Error(j.error || "script error");
        }
        async function tryDirectNoCors() {
          await fetch(WEBHOOK_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
            mode: "no-cors",
            cache: "no-store",
          });
        }

        try {
          await tryProxy();
          showToast(`‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å "${newStatus}" ‡πÅ‡∏•‡πâ‡∏ß (${name})`, "success");
        } catch (e) {
          console.warn("Proxy ‡∏™‡πà‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:", e);
          try {
            await tryDirectNoCors();
            await new Promise(res => setTimeout(res, 900)); // ‡∏£‡∏≠‡πÉ‡∏´‡πâ GAS ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ä‡∏µ‡∏ï
            await loadSheetData(); // ‡πÇ‡∏´‡∏•‡∏î‡∏ã‡πâ‡∏≥‡∏°‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
            const m = markerByName.get(name);
            if (m && (m.options.status || "") === newStatus) {
              showToast(`‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß (${name})`, "success");
            } else {
              throw new Error("verify-failed");
            }
          } catch (e2) {
            console.error("Direct fallback failed:", e2);
            showToast("‚ùå ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß (‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢/Proxy): ‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á", "error");
          }
        }
      }

      // ‡πÇ‡∏´‡∏•‡∏î‡∏ä‡∏µ‡∏ï + ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏°‡∏∏‡∏î
      async function loadSheetData() {
        try {
          const res = await fetch(SHEET_URL, { cache: "no-store" });
          const text = await res.text();

          // ‡∏•‡πâ‡∏≤‡∏á markers ‡πÄ‡∏Å‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
          markers.forEach(m => map.removeLayer(m));
          markers = [];
          markerByName.clear();

          const json = JSON.parse(text.substring(47).slice(0, -2));
          const rows = json.table.rows;
          const cols = json.table.cols;

          // map ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ï‡∏≤‡∏°‡∏ä‡∏µ‡∏ï‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÉ‡∏ä‡πâ
          const COL = {
            name:        colIndexByLabels(cols, ["name","‡∏ä‡∏∑‡πà‡∏≠","‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏≤"]),
            lat:         colIndexByLabels(cols, ["latitude","lat","‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î"]),
            lng:         colIndexByLabels(cols, ["longitude","lng","‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î"]),
            lastFix:     colIndexByLabels(cols, ["‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î"]),
            item:        colIndexByLabels(cols, ["‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£"]),
            mechanic:    colIndexByLabels(cols, ["‡∏ú‡∏π‡πâ‡∏ã‡πà‡∏≠‡∏°"]),
            photo:       colIndexByLabels(cols, ["‡∏£‡∏π‡∏õ‡∏ñ‡πà‡∏≤‡∏¢‡∏´‡∏ô‡πâ‡∏≤‡∏á‡∏≤‡∏ô","‡∏£‡∏π‡∏õ‡∏ñ‡πà‡∏≤‡∏¢"]),
            ticket:      colIndexByLabels(cols, ["‡πÉ‡∏ö‡πÅ‡∏à‡πâ‡∏á‡∏á‡∏≤‡∏ô"]),
            status:      colIndexByLabels(cols, ["status","‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞"]),
            lastEditor:  colIndexByLabels(cols, ["‡∏ú‡∏π‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î"]),
            lastUpdated: colIndexByLabels(cols, ["‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î","‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î"]),
            direction:   colIndexByLabels(cols, ["‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á","‡∏ó‡∏¥‡∏®"])
          };
          // fallback ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö 3 ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏´‡∏•‡∏±‡∏Å + status
          if (COL.name   < 0) COL.name = 0;
          if (COL.lat    < 0) COL.lat = 1;
          if (COL.lng    < 0) COL.lng = 2;
          if (COL.status < 0) COL.status = 8;

          rows.forEach((r, i) => {
            const rawName   = cell(r, COL.name);
            const rawLat    = cell(r, COL.lat);
            const rawLng    = cell(r, COL.lng);
            const rawStatus = cell(r, COL.status);

            const name   = toText(rawName);
            const status = toText(rawStatus);
            const latNum = toNumber(rawLat);
            const lngNum = toNumber(rawLng);
            if (!Number.isFinite(latNum) || !Number.isFinite(lngNum)) return;

            const meta = {
              lastFix:     cell(r, COL.lastFix),
              item:        cell(r, COL.item),
              mechanic:    cell(r, COL.mechanic),
              photo:       cell(r, COL.photo),
              ticket:      cell(r, COL.ticket),
              lastEditor:  cell(r, COL.lastEditor),
              lastUpdated: cell(r, COL.lastUpdated),
              direction:   cell(r, COL.direction),
            };

            const color = colorFor(status, name);
            const m = L.marker([latNum, lngNum], {
              icon: circleIcon(color),
              name,
              status,
              meta
            }).addTo(map);

            createPopup(m, name, status, color);
            markers.push(m);
            markerByName.set(name || `row_${i}`, m);
          });

          if (markers.length && (!firstDataLoaded || (AUTO_FIT_ON_REFRESH_WHEN_NOT_TRACKING && !watchID))) {
            map.fitBounds(L.featureGroup(markers).getBounds().pad(0.2));
            firstDataLoaded = true;
          }

          statusEl.innerHTML = "‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: " + new Date().toLocaleTimeString();
          applyFilters();
        } catch (e) {
          console.error(e);
          statusEl.textContent = "‚ùå ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à";
        }
      }

      // Bottom sheet logic
      function esc(s){ return String(s??"").replace(/[&<>"]/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c])); }
      function fill(el, v){ el.innerHTML = (v && String(v).trim()) ? esc(v) : "<span style='opacity:.6'>-</span>"; }
      let sheetMarker = null;
      function openSheetFor(marker){
        sheetMarker = marker;
        const m = marker.options;
        const meta = m.meta || {};
        dName.textContent = m.name || "-";
        fill(dItem, meta.item);
        fill(dMechanic, meta.mechanic);
        fill(dLastFix, meta.lastFix);
        fill(dDirection, meta.direction);
        fill(dLastEditor, meta.lastEditor);
        fill(dLastUpdated, meta.lastUpdated);
        dLinks.innerHTML = "";
        if (meta.photo)  dLinks.innerHTML += `üì∑ <a href="${esc(meta.photo)}" target="_blank" rel="noopener">‡∏£‡∏π‡∏õ‡∏ñ‡πà‡∏≤‡∏¢</a> `;
        if (meta.ticket) dLinks.innerHTML += `üìÑ <a href="${esc(meta.ticket)}" target="_blank" rel="noopener">‡πÉ‡∏ö‡πÅ‡∏à‡πâ‡∏á‡∏á‡∏≤‡∏ô</a> `;

        sheetEl.classList.remove("hidden");
        requestAnimationFrame(()=> sheetEl.classList.add("open"));
      }
      function closeSheet(){
        sheetEl.classList.remove("open");
        setTimeout(()=> sheetEl.classList.add("hidden"), 200);
      }
      sheetClose.addEventListener("click", closeSheet);
      sheetEl.addEventListener("click", (e)=>{ if(e.target===sheetEl) closeSheet(); });

      ["dOnA","dOnB","dOnAB","dOffA","dOffB","dOffAB"].forEach(id=>{
        document.getElementById(id).addEventListener("click", ()=>{
          if(!sheetMarker) return;
          const name = sheetMarker.options.name;
          const mapStatus = {
            dOnA:"‡πÑ‡∏ü‡∏ï‡∏¥‡∏îA", dOnB:"‡πÑ‡∏ü‡∏ï‡∏¥‡∏îB", dOnAB:"‡πÑ‡∏ü‡∏ï‡∏¥‡∏îAB",
            dOffA:"‡πÑ‡∏ü‡∏î‡∏±‡∏öA", dOffB:"‡πÑ‡∏ü‡∏î‡∏±‡∏öB", dOffAB:"‡πÑ‡∏ü‡∏î‡∏±‡∏öAB"
          };
          const newStatus = mapStatus[id];
          const newColor = colorFor(newStatus, name);
          sheetMarker.setIcon(circleIcon(newColor));
          sheetMarker.options.status = newStatus;

          const editor = (usernameInput?.value || "").trim() || "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡∏ï‡∏£‡∏ß‡∏à";
          sheetMarker.options.meta = sheetMarker.options.meta || {};
          sheetMarker.options.meta.lastEditor = editor;
          sheetMarker.options.meta.lastUpdated = new Date().toLocaleString();

          sendStatusToSheet(name, newStatus);
          applyFilters();
          showToast(`‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å "${newStatus}" ‡πÅ‡∏•‡πâ‡∏ß (${name})`, "success");
        });
      });

      // ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
      function startTracking() {
        if (watchID) return;
        showToast("üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á...", "success");
        trackBtn.textContent = "‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°";
        trackBtn.classList.add("stop");

        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen().catch(() => {});
        }

        watchID = navigator.geolocation.watchPosition(onPosition, onPositionError, {
          enableHighAccuracy: true,
          maximumAge: 0,
          timeout: 10000
        });
      }
      function stopTracking() {
        if (!watchID) return;
        navigator.geolocation.clearWatch(watchID);
        watchID = null;
        trackBtn.textContent = "‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°";
        trackBtn.classList.remove("stop");
        showToast("üõë ‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÅ‡∏•‡πâ‡∏ß", "info");

        if (document.fullscreenElement) {
          document.exitFullscreen().catch(() => {});
        }
      }

      trackBtn.onclick = () => { if (watchID) stopTracking(); else startTracking(); };
      refreshBtn.onclick = loadSheetData;

      function onPosition(pos) {
        const { latitude, longitude, accuracy } = pos.coords;
        const now = Date.now();

        // ‡∏û‡∏£‡∏µ‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠
        if ('ontouchstart' in window) {
          document.addEventListener('touchstart', ()=>{
            ding.play().then(()=>ding.pause()).catch(()=>{});
          }, { once:true });
        }

        if (userMarker) map.removeLayer(userMarker);
        if (userCircle) map.removeLayer(userCircle);
        userMarker = L.marker([latitude, longitude], { icon: L.divIcon({ html: "üìç" }) }).addTo(map);
        userCircle = L.circle([latitude, longitude], { radius: accuracy }).addTo(map);

        // ‡∏ï‡πà‡∏≠‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö‡∏°‡∏µ‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç
        const newLatLng = L.latLng(latitude, longitude);
        let addedPoint = false;
        if (userPath.length === 0) { userPath.push(newLatLng); addedPoint = true; }
        else {
          const last = userPath[userPath.length - 1];
          const moved = map.distance(last, newLatLng);
          if (moved >= MIN_STEP_M) { userPath.push(newLatLng); addedPoint = true; }
        }
        if (userPolyline) { if (addedPoint) userPolyline.addLatLng(newLatLng); }
        else { userPolyline = L.polyline(userPath, { color: "#007bff", weight: 4 }).addTo(map); }

        // ‡πÇ‡∏ü‡∏Å‡∏±‡∏™‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
        map.setView([latitude, longitude], Math.max(map.getZoom(), 17));

        // ‡πÅ‡∏™‡∏î‡∏á‡∏û‡∏¥‡∏Å‡∏±‡∏î
        statusEl.innerHTML = `üìç ${latitude.toFixed(5)}, ${longitude.toFixed(5)} (¬±${accuracy.toFixed(1)} m)`;

        // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÉ‡∏Å‡∏•‡πâ‡∏´‡∏°‡∏∏‡∏î (throttle)
        if (now - lastNearCheckAt >= NEAR_CHECK_MS) {
          lastNearCheckAt = now;
          checkNearbyMarkers(newLatLng, accuracy, now);
        }
      }
      function onPositionError() { showToast("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÑ‡∏î‡πâ!", "error"); }

      function checkNearbyMarkers(latlng, accuracy, nowTs) {
        if (accuracy > ACCURACY_TRIGGER_MAX_M) return;

        let nearest = null;
        let nearestDist = Infinity;
        // ‡πÄ‡∏ä‡πá‡∏Ñ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏´‡∏°‡∏∏‡∏î‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÅ‡∏™‡∏î‡∏á‡∏≠‡∏¢‡∏π‡πà (‡∏´‡∏•‡∏±‡∏á‡∏Å‡∏£‡∏≠‡∏á)
        for (const m of markers) {
          if (!map.hasLayer(m)) continue;
          const d = map.distance(latlng, m.getLatLng());
          if (d < nearestDist) { nearest = m; nearestDist = d; }
        }
        if (!nearest) return;

        const name = nearest.options.name || "(‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ä‡∏∑‡πà‡∏≠)";
        const lastPerPin = perPinNotifiedAt.get(name) || 0;
        const globalOk = (nowTs - lastGlobalNotifyAt) >= GLOBAL_COOLDOWN_MS;
        const perPinOk  = (nowTs - lastPerPin)        >= PER_PIN_COOLDOWN_MS;

        if (nearestDist <= ZOOM_IN_DIST_M && globalOk && perPinOk && !isZoomedIn) {
          isZoomedIn = true;
          perPinNotifiedAt.set(name, nowTs);
          lastGlobalNotifyAt = nowTs;

          map.setView(nearest.getLatLng(), 19, { animate: true });
          nearest.openPopup();
          ding.currentTime = 0; ding.play();
          showToast(`üì° ‡πÉ‡∏Å‡∏•‡πâ‡∏à‡∏∏‡∏î ${name} ‡∏£‡∏∞‡∏¢‡∏∞ ${nearestDist.toFixed(1)} ‡∏°.`, "info");
        }
        if (nearestDist >= ZOOM_OUT_DIST_M && isZoomedIn) { isZoomedIn = false; }
      }

      // FILTER logic
      function markerPassTypeFilter(m) {
        const name = (m.options.name || "");
        const st   = (m.options.status || "");
        switch (activeTypeFilter) {
          case "SP":   return isSP(name) || isSP(st);
          case "HM":   return isHM(name) || isHM(st);
          case "ON":   return /‡πÑ‡∏ü‡∏ï‡∏¥‡∏î/i.test(st);
          case "OFF":  return /‡πÑ‡∏ü‡∏î‡∏±‡∏ö/i.test(st);
          case "POLE": // ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏™‡∏≤‡πÑ‡∏ü = ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà SP/HM
            return !(isSP(name) || isHM(name) || isSP(st) || isHM(st));
          default:     return true; // ALL
        }
      }
      function markerPassSearch(m) {
        if (!searchQuery) return true;
        const name = (m.options.name || "").toLowerCase();
        return name.includes(searchQuery);
      }
      function applyFilters() {
        searchQuery = (searchInput?.value || "").trim().toLowerCase();
        markers.forEach(m => {
          const shouldShow = markerPassTypeFilter(m) && markerPassSearch(m);
          if (shouldShow) { if (!map.hasLayer(m)) m.addTo(map); }
          else { if (map.hasLayer(m)) map.removeLayer(m); }
        });
      }
      chipButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          activeTypeFilter = btn.dataset.type;
          chipButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          applyFilters();
        });
      });
      searchInput?.addEventListener("input", applyFilters);

      // ‡πÇ‡∏´‡∏•‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å + ‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏ó‡∏∏‡∏Å 5 ‡∏ô‡∏≤‡∏ó‡∏µ
      loadSheetData();
      setInterval(loadSheetData, 300000);

      // ‡πÅ‡∏ó‡πá‡∏ö‡∏ã‡πà‡∏≠‡∏ô ‚Üí ‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°
      document.addEventListener("visibilitychange", () => {
        if (document.hidden && watchID) stopTracking();
      });
    };
  </script>
</body>
</html>
