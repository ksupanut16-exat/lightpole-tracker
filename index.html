<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>GPS Tracker + ‡πÄ‡∏™‡∏≤‡πÑ‡∏ü (‡∏ü‡∏¥‡∏•‡πÄ‡∏ï‡∏≠‡∏£‡πå + ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ + ‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô‡πÉ‡∏Å‡∏•‡πâ‡∏à‡∏∏‡∏î)</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; padding: 0; font-family: "Segoe UI", Tahoma, sans-serif; background: #f5f6fa; }
    #map { height: 100vh; width: 100%; z-index: 1; }

    .leaflet-top.leaflet-left { top: 50px !important; }

    .status-bar {
      position: fixed; bottom: 10px; left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px 14px; border-radius: 10px;
      font-size: 14px; box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      z-index: 1000; line-height: 1.4; max-width: 90%;
    }

    .user-input {
      position: fixed; bottom: 65px; left: 10px;
      background: rgba(255,255,255,0.95);
      padding: 10px 12px; border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      z-index: 2000; display: flex; align-items: center; gap: 8px;
    }
    .user-input input {
      border: 1px solid #ccc; border-radius: 6px;
      padding: 5px 8px; font-size: 14px; width: 150px;
    }

    .refresh-btn, .track-btn {
      position: fixed; top: 15px;
      background: #007bff; color: white; border: none;
      padding: 10px 14px; border-radius: 8px;
      font-size: 14px; font-weight: bold; cursor: pointer;
      box-shadow: 0 2px 5px rgba(0,0,0,0.3);
      transition: background 0.2s ease; z-index: 2000;
    }
    .refresh-btn { right: 15px; }
    .track-btn { left: 15px; background: #28a745; }
    .track-btn.stop { background: #dc3545; }

    .legend {
      position: fixed; bottom: 20px; right: 20px;
      background: rgba(255,255,255,0.95);
      padding: 10px 12px; border-radius: 8px;
      font-size: 13px; box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      line-height: 1.6; z-index: 9999;
    }
    .legend div { display: flex; align-items: center; gap: 6px; }
    .legend-color { width: 14px; height: 14px; border-radius: 50%; border: 1px solid #666; }

    .toast {
      position: fixed; top: 20px; right: 20px;
      background: #333; color: white;
      padding: 12px 20px; border-radius: 6px;
      font-size: 14px; opacity: 0;
      transition: opacity 0.5s, transform 0.3s;
      z-index: 3000; transform: translateY(-20px);
    }
    .toast.show { opacity: 1; transform: translateY(0); }

    .btn-row { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 6px; }
    .btn { border: none; border-radius: 6px; padding: 6px 10px; cursor: pointer; font-size: 13px; }
    .btn-green { background: #28a745; color: #fff; }
    .btn-red   { background: #dc3545; color: #fff; }

    .leaflet-div-icon { background: transparent !important; border: none !important; box-shadow: none !important; }

    /* ===== FILTER UI (‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ö‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°) ===== */
    .top-controls{
      position: fixed; top: 15px; left: 15px;
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
      z-index: 2000;
    }
    .top-controls .track-btn{
      position: static !important; left: auto !important; top: auto !important;
    }
    .top-controls .filter-bar{
      position: static !important;
      display: flex; align-items: center; gap: 8px;
      background: rgba(255,255,255,0.95);
      padding: 8px 10px; border-radius: 10px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.25);
      flex-wrap: nowrap; white-space: nowrap; overflow-x: auto;
      max-width: 92vw;
    }
    .top-controls .filter-bar input{
      flex: 0 0 auto; width: 140px;
      border: 1px solid #ccc; border-radius: 6px; padding: 6px 8px; font-size: 13px;
    }
    .top-controls .filter-bar .chip{ flex: 0 0 auto; }
    .chip{
      border: 1px solid #ccc; background: #fff;
      padding: 6px 10px; border-radius: 999px; font-size: 13px; cursor: pointer;
      user-select: none;
    }
    .chip.active{ background:#111; color:#fff; border-color:#111; }
    @media (max-width: 600px){
      .top-controls{ gap: 8px; }
      .top-controls .filter-bar{ max-width: 88vw; }
      .top-controls .filter-bar input{ flex: 1; min-width: 120px; }
    }
  </style>
</head>
<body>
  <div class="user-input">
    <label for="username">üë§ ‡∏ú‡∏π‡πâ‡∏ï‡∏£‡∏ß‡∏à:</label>
    <input type="text" id="username" placeholder="‡∏£‡∏∞‡∏ö‡∏∏‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏ï‡∏£‡∏ß‡∏à" />
  </div>

  <!-- ‡∏Ñ‡∏≠‡∏ô‡πÇ‡∏ó‡∏£‡∏•‡∏°‡∏∏‡∏°‡∏ã‡πâ‡∏≤‡∏¢‡∏ö‡∏ô -->
  <div class="top-controls">
    <button id="trackBtn" class="track-btn">‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°</button>
    <div class="filter-bar">
      <input type="text" id="searchInput" placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏≤‚Ä¶" />
      <button class="chip active" data-type="ALL">‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</button>
      <button class="chip" data-type="POLE">‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏™‡∏≤‡πÑ‡∏ü</button>
      <button class="chip" data-type="SP">‡πÄ‡∏â‡∏û‡∏≤‡∏∞ SP</button>
      <button class="chip" data-type="HM">‡πÄ‡∏â‡∏û‡∏≤‡∏∞ HM</button>
      <button class="chip" data-type="ON">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î</button>
      <button class="chip" data-type="OFF">‡πÑ‡∏ü‡∏î‡∏±‡∏ö</button>
    </div>
  </div>

  <button id="refreshBtn" class="refresh-btn">üîÑ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ</button>

  <div id="map"></div>
  <div id="status" class="status-bar">üïì ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà...</div>

  <div class="legend">
    <b>üó∫Ô∏è ‡∏Ñ‡∏≥‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡∏™‡∏µ:</b>
    <div><span class="legend-color" style="background: #ff66b2;"></span> SP</div>
    <div><span class="legend-color" style="background: #ffd54f;"></span> HM</div>
    <div><span class="legend-color" style="background: green;"></span> ‡πÑ‡∏ü‡∏ï‡∏¥‡∏î (A/B/AB)</div>
    <div><span class="legend-color" style="background: red;"></span> ‡πÑ‡∏ü‡∏î‡∏±‡∏ö (A/B/AB)</div>
  </div>

  <div id="toast" class="toast"></div>
  <audio id="ding" src="https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg" preload="auto"></audio>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    /* ===== CONFIG (‡πÅ‡∏Å‡πâ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Å‡∏ï‡πå‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì) ===== */
    // 1) URL ‡∏Ç‡∏≠‡∏á Web App ("/exec") ‡∏ó‡∏µ‡πà Deploy ‡πÅ‡∏•‡πâ‡∏ß
    const WEBHOOK_URL = "https://script.google.com/macros/s/AKfycbzgw0Qs5-MvsolZD4ncD4tzixdVQ4kYHraDIZQOgs_V5cqMYgQ647-2RmFoxBj4NV160g/exec"; // ‚Üê ‡πÅ‡∏Å‡πâ!
    // 2) Proxy ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á CORS (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö redirect ‡πÑ‡∏î‡πâ‡∏î‡∏µ)
    const PROXY = "https://corsproxy.io/?";
    // 3) ‡∏ä‡∏µ‡∏ï‡∏ó‡∏µ‡πà‡∏≠‡πà‡∏≤‡∏ô‡∏´‡∏°‡∏∏‡∏î (‡πÉ‡∏ä‡πâ gviz)
    const SHEET_ID = "1LgTGHbgIkHEkH53qkzrNc0haIt5RV5eYydtN7Qm7bcQ"; // ‚Üê ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö Code.gs
    const SHEET_GID = ""; // ‡∏ñ‡πâ‡∏≤‡∏à‡∏∞‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÅ‡∏ó‡πá‡∏ö: ‡πÉ‡∏™‡πà gid (‡πÄ‡∏ä‡πà‡∏ô "0"); ‡∏ß‡πà‡∏≤‡∏á = ‡πÅ‡∏ó‡πá‡∏ö‡πÅ‡∏£‡∏Å
    const SHEET_URL = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json`;

    /* ===== TUNING ===== */
    const MIN_STEP_M = 2;
    const NEAR_CHECK_MS = 3000;
    const ACCURACY_TRIGGER_MAX_M = 30;
    const ZOOM_IN_DIST_M = 5;
    const ZOOM_OUT_DIST_M = 10;
    const PER_PIN_COOLDOWN_MS = 90_000;
    const GLOBAL_COOLDOWN_MS  = 6_000;
    const AUTO_FIT_ON_REFRESH_WHEN_NOT_TRACKING = true;

    /* ===== Helper: ‡πÄ‡∏ï‡∏¥‡∏°‡∏ä‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏à‡∏≤‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ (‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö SP/HM/SO+‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç) ===== */
    const NAME_FALLBACK_SET = new Set(["SP01","SO02","SP03","HM01","HM02","HM03"]);
    const toId = (x) => (x ?? "").toString().trim().toUpperCase();
    function extractCode(str) {
      const s = (str ?? "").toString().trim();
      if (!s) return null;
      const m = s.toUpperCase().match(/\b(SP|HM|SO)\s*[- ]?\s*0*(\d{1,4})\b/);
      return m ? `${m[1]}${m[2]}` : null;
    }
    function deriveName(nameRaw, statusRaw) {
      const nameTxt = (nameRaw ?? "").toString().trim();
      if (nameTxt) return nameTxt;
      const idFromStatus = toId(statusRaw);
      if (NAME_FALLBACK_SET.has(idFromStatus)) return idFromStatus;
      const codeFromStatus = extractCode(statusRaw);
      return codeFromStatus || "";
    }

    window.onload = () => {
      const map = L.map('map').setView([13.639845, 100.621484], 16);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

      const toast = document.getElementById("toast");
      const ding = document.getElementById("ding");
      const usernameInput = document.getElementById("username");
      const statusEl = document.getElementById("status");
      const trackBtn = document.getElementById("trackBtn");
      const refreshBtn = document.getElementById("refreshBtn");

      /* === FILTER refs/state === */
      const searchInput = document.getElementById("searchInput");
      const chipButtons = Array.from(document.querySelectorAll(".chip"));
      let activeTypeFilter = "ALL"; // ALL | POLE | SP | HM | ON | OFF
      let searchQuery = "";
      /* === /FILTER refs/state === */

      let markers = [];
      let markerByName = new Map();
      let userMarker = null, userCircle = null;
      let userPath = [];
      let userPolyline = null;
      let watchID = null;
      let isZoomedIn = false;
      let firstDataLoaded = false;

      // throttling & cooldown
      let lastNearCheckAt = 0;
      let lastGlobalNotifyAt = 0;
      const perPinNotifiedAt = new Map(); // name -> ts

      function showToast(msg, type="info") {
        toast.textContent = msg;
        toast.style.background = type === "success" ? "#28a745" : type === "error" ? "#dc3545" : "#333";
        toast.classList.add("show");
        setTimeout(() => toast.classList.remove("show"), 3000);
      }
      function toNumber(x) {
        if (typeof x === "number") return x;
        if (typeof x === "string") {
          const cleaned = x.trim().replace(/,/g, ".").replace(/[^\d.\-]/g, "");
          const n = Number(cleaned);
          return Number.isFinite(n) ? n : NaN;
        }
        return NaN;
      }
      function toText(x) { return (x ?? "").toString().trim(); }

      function getCodePrefix(x){
        const s = (x ?? "").toString().trim().toUpperCase();
        if (!s) return null;
        let m = s.match(/^(SP|HM)\b/);
        if (m) return m[1];
        m = s.match(/\b(SP|HM)\s*[- ]?\s*\d+/);
        return m ? m[1] : null;
      }
      function isSP(x){ return getCodePrefix(x) === "SP"; }
      function isHM(x){ return getCodePrefix(x) === "HM"; }

      function colorFor(status, name) {
        const s = toText(status);
        const nm = toText(name);
        if (/^SP/i.test(s) || /^SP/i.test(nm)) return "#ff66b2";
        if (/^HM/i.test(s) || /^HM/i.test(nm)) return "#ffd54f";
        if (/‡πÑ‡∏ü‡∏î‡∏±‡∏ö/i.test(s)) return "red";
        if (/‡πÑ‡∏ü‡∏ï‡∏¥‡∏î/i.test(s)) return "green";
        return "blue";
      }
      function circleIcon(color) {
        return L.divIcon({
          html: `<div style="background:${color};width:18px;height:18px;border-radius:50%;border:2px solid white;"></div>`,
          className: ""
        });
      }

      /* ===== ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ ‚Üí GET ‡∏ú‡πà‡∏≤‡∏ô proxy (‡∏Å‡∏±‡∏ô 502/redirect) ===== */
      async function sendStatusToSheet(name, newStatus) {
  const user = usernameInput.value.trim() || "‡πÑ‡∏°‡πà‡∏£‡∏∞‡∏ö‡∏∏‡∏ú‡∏π‡πâ‡∏ï‡∏£‡∏ß‡∏à";
  const payload = { name, status: newStatus, user };
  const proxyUrl = PROXY + encodeURIComponent(WEBHOOK_URL) + "&_ts=" + Date.now();

  async function tryProxy() {
    const r = await fetch(proxyUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json", "Cache-Control": "no-store" },
      body: JSON.stringify(payload),
      cache: "no-store",
    });
    if (!r.ok) throw new Error("proxy " + r.status);
    const j = await r.json();
    if (!j.ok) throw new Error(j.error || "script error");
  }

  async function tryDirectNoCors() {
    // ‡∏¢‡∏¥‡∏á‡∏ï‡∏£‡∏á‡πÑ‡∏õ Apps Script ‡πÅ‡∏ö‡∏ö no-cors (‡∏à‡∏∞‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏≠‡πà‡∏≤‡∏ô‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå ‡πÅ‡∏ï‡πà‡∏™‡πà‡∏ß‡∏ô‡πÉ‡∏´‡∏ç‡πà‡∏™‡πà‡∏á‡∏ñ‡∏∂‡∏á‡πÅ‡∏ô‡πà ‡πÜ)
    await fetch(WEBHOOK_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
      mode: "no-cors",
      cache: "no-store",
    });
  }

  try {
    await tryProxy();
    showToast(`‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å "${newStatus}" ‡πÅ‡∏•‡πâ‡∏ß (${name})`, "success");
  } catch (e) {
    console.warn("Proxy ‡∏™‡πà‡∏á‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:", e);

    // Fallback ‡∏¢‡∏¥‡∏á‡∏ï‡∏£‡∏á ‚Üí ‡πÅ‡∏•‡πâ‡∏ß‡∏£‡∏µ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ä‡∏µ‡∏ï‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
    try {
      await tryDirectNoCors();
      // ‡πÄ‡∏ß‡πâ‡∏ô‡πÉ‡∏´‡πâ GAS ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô‡∏ä‡∏µ‡∏ï‡πÄ‡∏™‡∏µ‡πâ‡∏¢‡∏ß‡∏ß‡∏¥ ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡πÇ‡∏´‡∏•‡∏î‡∏ã‡πâ‡∏≥‡∏°‡∏≤‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô
      await new Promise(res => setTimeout(res, 900));
      await loadSheetData();

      const m = markerByName.get(name);
      if (m && String(m.options.status || "").includes(newStatus.replace("‡πÑ‡∏ü",""))) {
        showToast(`‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÅ‡∏•‡πâ‡∏ß (${name})`, "success");
      } else {
        throw new Error("verify-failed");
      }
    } catch (e2) {
      console.error("Direct fallback failed:", e2);
      showToast("‚ùå ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß (‡πÄ‡∏Ñ‡∏£‡∏∑‡∏≠‡∏Ç‡πà‡∏≤‡∏¢/Proxy): ‡∏•‡∏≠‡∏á‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á", "error");
    }
  }
}



      function createPopup(marker, name, status, color) {
        const div = document.createElement("div");
        div.innerHTML = `
          <b>${name}</b><br>
          üî∞ <b id="statusText" style="color:${color}">${status || "-"}</b><br><br>
          <div class="btn-row">
            <button class="btn btn-green" id="onA">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î A</button>
            <button class="btn btn-green" id="onB">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î B</button>
            <button class="btn btn-green" id="onAB">‡πÑ‡∏ü‡∏ï‡∏¥‡∏î AB</button>
            <button class="btn btn-red"   id="offA">‡πÑ‡∏ü‡∏î‡∏±‡∏ö A</button>
            <button class="btn btn-red"   id="offB">‡πÑ‡∏ü‡∏î‡∏±‡∏ö B</button>
            <button class="btn btn-red"   id="offAB">‡πÑ‡∏ü‡∏î‡∏±‡∏ö AB</button>
          </div>
        `;
        const popup = L.popup().setContent(div);
        marker.bindPopup(popup);

        marker.on("popupopen", () => {
          const statusTextEl = div.querySelector("#statusText");
          function updateStatus(newStatus) {
            const newColor = colorFor(newStatus, name);
            statusTextEl.style.color = newColor;
            statusTextEl.textContent = newStatus;
            marker.setIcon(circleIcon(newColor));
            marker.options.status = newStatus; // ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡∏Å‡∏±‡∏ö‡∏ï‡∏±‡∏ß‡∏Å‡∏£‡∏≠‡∏á
            ding.currentTime = 0; ding.play();
            marker.closePopup();
            sendStatusToSheet(name, newStatus);
            applyFilters(); // ‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏ú‡∏•‡∏Å‡∏£‡∏≠‡∏á
          }
          div.querySelector("#onA").onclick  = () => updateStatus("‡πÑ‡∏ü‡∏ï‡∏¥‡∏îA");
          div.querySelector("#onB").onclick  = () => updateStatus("‡πÑ‡∏ü‡∏ï‡∏¥‡∏îB");
          div.querySelector("#onAB").onclick = () => updateStatus("‡πÑ‡∏ü‡∏ï‡∏¥‡∏îAB");
          div.querySelector("#offA").onclick = () => updateStatus("‡πÑ‡∏ü‡∏î‡∏±‡∏öA");
          div.querySelector("#offB").onclick = () => updateStatus("‡πÑ‡∏ü‡∏î‡∏±‡∏öB");
          div.querySelector("#offAB").onclick= () => updateStatus("‡πÑ‡∏ü‡∏î‡∏±‡∏öAB");
        });
      }
// ‡∏´‡∏≤ index ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏à‡∏≤‡∏Å label (‡∏´‡∏±‡∏ß‡∏ï‡∏≤‡∏£‡∏≤‡∏á) ‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏ô‡∏†‡∏≤‡∏©‡∏≤/‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á/‡∏ï‡∏±‡∏ß‡∏û‡∏¥‡∏°‡∏û‡πå
function colIndexByLabels(cols, candidates){
  return cols.findIndex(c => {
    const label = (c?.label ?? "").toString().trim().toLowerCase();
    return candidates.some(x => label === x.toLowerCase());
  });
}

// ‡∏≠‡πà‡∏≤‡∏ô‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å‡πÄ‡∏ã‡∏•‡∏•‡πå: ‡πÄ‡∏≠‡∏≤ v ‡∏Å‡πà‡∏≠‡∏ô ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡πà‡∏≠‡∏¢‡∏•‡∏≠‡∏á f
function cell(r, idx){
  return r?.c?.[idx]?.v ?? r?.c?.[idx]?.f ?? "";
}

     async function loadSheetData() {
  try {
    const res = await fetch(SHEET_URL);
    const text = await res.text();

    // ‡∏•‡πâ‡∏≤‡∏á markers ‡πÄ‡∏Å‡πà‡∏≤
    markers.forEach(m => map.removeLayer(m));
    markers = [];
    markerByName.clear();

    const json = JSON.parse(text.substring(47).slice(0, -2));
    const rows = json.table.rows;
    const cols = json.table.cols;

    // ‡πÅ‡∏°‡πá‡∏û‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå‡∏ï‡∏≤‡∏°‡∏´‡∏±‡∏ß‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì
    const COL = {
      name:        colIndexByLabels(cols, ["name","‡∏ä‡∏∑‡πà‡∏≠","‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏≤"]),
      lat:         colIndexByLabels(cols, ["latitude","lat","‡∏•‡∏∞‡∏ï‡∏¥‡∏à‡∏π‡∏î"]),
      lng:         colIndexByLabels(cols, ["longitude","lng","‡∏•‡∏≠‡∏á‡∏à‡∏¥‡∏à‡∏π‡∏î"]),
      lastFix:     colIndexByLabels(cols, ["‡∏Å‡∏≤‡∏£‡∏ã‡πà‡∏≠‡∏°‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î"]),
      item:        colIndexByLabels(cols, ["‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£"]),
      mechanic:    colIndexByLabels(cols, ["‡∏ú‡∏π‡πâ‡∏ã‡πà‡∏≠‡∏°"]),
      photo:       colIndexByLabels(cols, ["‡∏£‡∏π‡∏õ‡∏ñ‡πà‡∏≤‡∏¢‡∏´‡∏ô‡πâ‡∏≤‡∏á‡∏≤‡∏ô","‡∏£‡∏π‡∏õ‡∏ñ‡πà‡∏≤‡∏¢"]),
      ticket:      colIndexByLabels(cols, ["‡πÉ‡∏ö‡πÅ‡∏à‡πâ‡∏á‡∏á‡∏≤‡∏ô"]),
      status:      colIndexByLabels(cols, ["status","‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞"]),
      lastEditor:  colIndexByLabels(cols, ["‡∏ú‡∏π‡πâ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î"]),
      lastUpdated: colIndexByLabels(cols, ["‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î","‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î"]),
      direction:   colIndexByLabels(cols, ["‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á","‡∏ó‡∏¥‡∏®"])
    };

    // fallback ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥ (‡∏Å‡∏±‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡∏´‡∏±‡∏ß‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏û‡∏¥‡∏°‡∏û‡πå‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á)
    if (COL.name   < 0) COL.name = 0;
    if (COL.lat    < 0) COL.lat = 1;
    if (COL.lng    < 0) COL.lng = 2;
    if (COL.status < 0) COL.status = 8;

    rows.forEach((r, i) => {
      const rawName   = cell(r, COL.name);
      const rawLat    = cell(r, COL.lat);
      const rawLng    = cell(r, COL.lng);
      const rawStatus = cell(r, COL.status);

      const name   = toText(rawName);
      const status = toText(rawStatus);
      const latNum = toNumber(rawLat);
      const lngNum = toNumber(rawLng);

      if (!Number.isFinite(latNum) || !Number.isFinite(lngNum)) {
        console.warn(`[skip row ${i}] invalid lat/lng`, { name, rawLat, rawLng });
        return;
      }

      const color = colorFor(status, name);
      const m = L.marker([latNum, lngNum], {
        icon: circleIcon(color),
        name,
        status,
        // ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏™‡∏£‡∏¥‡∏°‡πÑ‡∏ß‡πâ‡∏î‡πâ‡∏ß‡∏¢ (‡πÄ‡∏ú‡∏∑‡πà‡∏≠‡∏≠‡∏¢‡∏≤‡∏Å‡πÉ‡∏ä‡πâ‡πÉ‡∏ô popup ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á)
        meta: {
          lastFix:     cell(r, COL.lastFix),
          item:        cell(r, COL.item),
          mechanic:    cell(r, COL.mechanic),
          photo:       cell(r, COL.photo),
          ticket:      cell(r, COL.ticket),
          lastEditor:  cell(r, COL.lastEditor),
          lastUpdated: cell(r, COL.lastUpdated),
          direction:   cell(r, COL.direction),
        }
      }).addTo(map);

      createPopup(m, name, status, color);
      markers.push(m);
      markerByName.set(name || `row_${i}`, m);
    });

    if (markers.length && (!firstDataLoaded || (AUTO_FIT_ON_REFRESH_WHEN_NOT_TRACKING && !watchID))) {
      map.fitBounds(L.featureGroup(markers).getBounds().pad(0.2));
      firstDataLoaded = true;
    }

    statusEl.innerHTML = "‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: " + new Date().toLocaleTimeString();
    applyFilters();
  } catch (e) {
    console.error(e);
    statusEl.textContent = "‚ùå ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à";
  }
}


      function startTracking() {
        if (watchID) return;
        showToast("üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á...", "success");
        trackBtn.textContent = "‚è∏Ô∏è ‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°";
        trackBtn.classList.add("stop");
        if (document.documentElement.requestFullscreen) {
          document.documentElement.requestFullscreen().catch(() => {});
        }
        watchID = navigator.geolocation.watchPosition(onPosition, onPositionError, {
          enableHighAccuracy: true,
          maximumAge: 1000,
          timeout: 10000
        });
      }
      function stopTracking() {
        if (!watchID) return;
        navigator.geolocation.clearWatch(watchID);
        watchID = null;
        trackBtn.textContent = "‚ñ∂Ô∏è ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°";
        trackBtn.classList.remove("stop");
        showToast("üõë ‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÅ‡∏•‡πâ‡∏ß", "info");
        if (document.fullscreenElement) {
          document.exitFullscreen().catch(() => {});
        }
      }
      trackBtn.onclick = () => { if (watchID) stopTracking(); else startTracking(); };
      refreshBtn.onclick = loadSheetData;

      function onPosition(pos) {
        const { latitude, longitude, accuracy } = pos.coords;
        const now = Date.now();

        if (userMarker) map.removeLayer(userMarker);
        if (userCircle) map.removeLayer(userCircle);
        userMarker = L.marker([latitude, longitude], { icon: L.divIcon({ html: "üìç" }) }).addTo(map);
        userCircle = L.circle([latitude, longitude], { radius: accuracy }).addTo(map);

        const newLatLng = L.latLng(latitude, longitude);
        let addedPoint = false;
        if (userPath.length === 0) { userPath.push(newLatLng); addedPoint = true; }
        else {
          const last = userPath[userPath.length - 1];
          const moved = map.distance(last, newLatLng);
          if (moved >= MIN_STEP_M) { userPath.push(newLatLng); addedPoint = true; }
        }
        if (userPolyline) { if (addedPoint) userPolyline.addLatLng(newLatLng); }
        else { userPolyline = L.polyline(userPath, { color: "#007bff", weight: 4 }).addTo(map); }

        map.setView([latitude, longitude], Math.max(map.getZoom(), 17));
        statusEl.innerHTML = `üìç ${latitude.toFixed(5)}, ${longitude.toFixed(5)} (¬±${accuracy.toFixed(1)} m)`;

        if (now - lastNearCheckAt >= NEAR_CHECK_MS) {
          lastNearCheckAt = now;
          checkNearbyMarkers(newLatLng, accuracy, now);
        }
      }
      function onPositionError() { showToast("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏£‡∏∞‡∏ö‡∏∏‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÑ‡∏î‡πâ!", "error"); }

      function checkNearbyMarkers(latlng, accuracy, nowTs) {
        if (accuracy > ACCURACY_TRIGGER_MAX_M) return;
        let nearest = null, nearestDist = Infinity;

        for (const m of markers) {
          if (!map.hasLayer(m)) continue;
          const d = map.distance(latlng, m.getLatLng());
          if (d < nearestDist) { nearest = m; nearestDist = d; }
        }
        if (!nearest) return;

        const name = nearest.options.name || "(‡πÑ‡∏°‡πà‡∏ó‡∏£‡∏≤‡∏ö‡∏ä‡∏∑‡πà‡∏≠)";
        const lastPerPin = perPinNotifiedAt.get(name) || 0;
        const globalOk = (nowTs - lastGlobalNotifyAt) >= GLOBAL_COOLDOWN_MS;
        const perPinOk  = (nowTs - lastPerPin)        >= PER_PIN_COOLDOWN_MS;

        if (nearestDist <= ZOOM_IN_DIST_M && globalOk && perPinOk && !isZoomedIn) {
          isZoomedIn = true;
          perPinNotifiedAt.set(name, nowTs);
          lastGlobalNotifyAt = nowTs;

          map.setView(nearest.getLatLng(), 19, { animate: true });
          nearest.openPopup();
          ding.currentTime = 0; ding.play();
          showToast(`üì° ‡πÉ‡∏Å‡∏•‡πâ‡∏à‡∏∏‡∏î ${name} ‡∏£‡∏∞‡∏¢‡∏∞ ${nearestDist.toFixed(1)} ‡∏°.`, "info");
        }
        if (nearestDist >= ZOOM_OUT_DIST_M && isZoomedIn) { isZoomedIn = false; }
      }

      /* === FILTER logic === */
      function markerPassTypeFilter(m) {
        const name = (m.options.name || "");
        const st   = (m.options.status || "");

        switch (activeTypeFilter) {
          case "SP":   return isSP(name) || isSP(st);
          case "HM":   return isHM(name) || isHM(st);
          case "ON":   return /‡πÑ‡∏ü‡∏ï‡∏¥‡∏î/i.test(st);
          case "OFF":  return /‡πÑ‡∏ü‡∏î‡∏±‡∏ö/i.test(st);
          case "POLE": // ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÄ‡∏™‡∏≤‡πÑ‡∏ü‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà SP/HM)
            return !(isSP(name) || isHM(name) || isSP(st) || isHM(st));
          default:     return true; // ALL
        }
      }
      function markerPassSearch(m) {
        if (!searchQuery) return true;
        const name = (m.options.name || "").toLowerCase();
        return name.includes(searchQuery);
      }
      function applyFilters() {
        searchQuery = (searchInput?.value || "").trim().toLowerCase();
        markers.forEach(m => {
          const shouldShow = markerPassTypeFilter(m) && markerPassSearch(m);
          if (shouldShow) { if (!map.hasLayer(m)) m.addTo(map); }
          else            { if (map.hasLayer(m)) map.removeLayer(m); }
        });
      }
      chipButtons.forEach(btn => {
        btn.addEventListener("click", () => {
          activeTypeFilter = btn.dataset.type;
          chipButtons.forEach(b => b.classList.remove("active"));
          btn.classList.add("active");
          applyFilters();
        });
      });
      searchInput?.addEventListener("input", applyFilters);

      // ‡πÇ‡∏´‡∏•‡∏î‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å + ‡∏£‡∏µ‡πÄ‡∏ü‡∏£‡∏ä‡∏ó‡∏∏‡∏Å 5 ‡∏ô‡∏≤‡∏ó‡∏µ
      loadSheetData();
      setInterval(loadSheetData, 300000);

      // ‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î‡πÅ‡∏ö‡∏ï/‡πÄ‡∏ô‡πá‡∏ï: ‡∏ã‡πà‡∏≠‡∏ô‡πÅ‡∏ó‡πá‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°
      document.addEventListener("visibilitychange", () => {
        if (document.hidden && watchID) stopTracking();
      });
    };
  </script>
</body>
</html>
